# 课程安排

- django框架
- 美多商城
- drf+美多商城后台

# 今天知识点

- 开发Web应用的模式
- RESTful协议
- 使用Django开发REST接口
- 明确REST接口开发的核心任务
- drf开发预览
- 序列化

# 开发Web应用的模式

- 前后端分离
- 前后端不分离
- 区别：
    - 服务器端返回给客户端的数据中，有没有包含显示的内容
    - 通常分离时采用json数据格式
- 前端：web，微信小程序，手机app，定制终端
- 后端：python，java

# RESTful协议

- 路径：名词，复数
- 请求方式：get,post,put,delete
- 过滤信息：查询条件，排序，分页，通过查询参数指定
- 状态码：200，201，204
- 返回结果：json格式
    - 查询多条：[{},{},{},....]
    - 查询一条：{}
    - 新建：{}
    - 修改：{}
    - 删除：无

# 使用Django开发REST接口

- 以图书book的操作为例，演示restful规范

操作 | 路径 | 请求方式 | 状态码 | 返回值
---|---|---|---|---
查询多个|books/|get|200|[{},{},...]
查询一个|books/(?P<pk>\d+)/|get|200|{}
增加|books/|post|201|{}
修改|books/(?P<pk>\d+)/|put|201|{}
删除|books/(?P<pk>\d+)/|delete|204|无

# drf开发预览

- 重复的代码：
    - 实例转字典===========》查询多条、创建、查询一条、修改
    - 根据主键查询实例=====》查询一条、修改、删除
    - 接收json数据并验证===》创建、修改
- 包drf符合restful规范，封装好了所有视图代码

# 明确REST接口开发的核心任务

- 序列化：将python实例转换成字典
- 反序列化：将字典转换成python实例

# 序列化

- 实现步骤：
    - 1.新建serializers.py文件
    - 2.定义序列化器类型，继承自drf的Serializer
    - 3.根据模型类定义属性
    - 4.在视图中调用：实例化，data属性
- 说明：参数many=True
- 关系属性序列化
    - 方式一：主键
    - 方式二：字符串
    - 方式三：自定义序列化，嵌套
    - 说明：read_only=True
    - 说明：在一端的关系属性，需要指定many=True

# 反序列化

- 封装的代码：
    - 验证
    - 创建
    - 修改

# 验证

- json.loads(request.body.decode())
- 验证方式
    - 1.类型
    - 2.约束
    - 3.自定义方法
- 调用
    - 1.创建实例，参数为字典
    - 2.调用方法is_valid()
    - 3.判断
        - 3.1如果返回True表示验证成功===》validated_data
        - 3.2如果返回False表示验证失败===>errors

# 总结

### 重要知识点

- RESTful规范：路径、请求方式、状态码、返回值
- 序列化：将实例转字典
    - 1.定义序列化器类型
    - 2.根据模型类属性定义属性
    - 3.创建实例，以模型类实例为参数
    - 4.调用data属性获取字典
- 反序列化--验证
    - 1.定义序列化器类型
    - 2.定义属性、参数、方法
    - 3.创建实例，以请求报文中的字典为参数
    - 4.方法is_valid()
    - 5.属性validated_data
    - 6.属性erros

### 作业

- 使用django实现图书的crud，遵守restful规范
- 练习使用序列化器进行序列化化实现

### 大纲要求

- 能够知道前后端分离和不分离开发模式的区别

```
服务器端返回json表示分离
服务器端返回数据+html代码表示不分离
```

- 能够知道RESTful设计风格的特点

```
路径：名词，复数
请求方式：get,post,put,delete
状态码:200,201,204
返回值：删除时无返回值
```

- 能够使用序列化器序列化模型对象

```
serialzier=***Serializer(模型类实例)
serializer.data===>字典
```
